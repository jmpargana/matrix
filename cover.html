
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">matrix/constructors.go (78.6%)</option>
				
				<option value="file1">matrix/get_set.go (100.0%)</option>
				
				<option value="file2">matrix/ops_funcs.go (82.1%)</option>
				
				<option value="file3">matrix/ops_helpers.go (100.0%)</option>
				
				<option value="file4">matrix/ops_methods.go (78.7%)</option>
				
				<option value="file5">matrix/stringer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package matrix

import (
        "fmt"
        "math/rand"
        "time"
)

// New creates a new empty matrix of a given size.
func New(rows, cols int) Matrix <span class="cov8" title="1">{
        assertValidSize(rows, cols)
        return createWithData(rows, cols, make([]float64, rows*cols))
}</span>

// NewSquare creates an empty square matrix of a given size.
func NewSquare(size int) Matrix <span class="cov8" title="1">{
        assertValidSize(size, size)
        return createWithData(size, size, make([]float64, size*size))
}</span>

// NewRandom creates a matrix of a given size and fills the vectors with random
// floating point number ranging from 0..1
func NewRandom(rows, cols int) Matrix <span class="cov0" title="0">{
        assertValidSize(rows, cols)

        data := make([]float64, 0, rows*cols)
        gen := rand.New(rand.NewSource(time.Now().UnixNano()))

        for i := range data </span><span class="cov0" title="0">{
                data[i] = gen.Float64()
        }</span>

        <span class="cov0" title="0">return createWithData(rows, cols, data)</span>
}

// NewFrom creates a matrix instance from a slice of slices
func NewFrom(data [][]float64) Matrix <span class="cov8" title="1">{
        rows, cols := len(data), len(data[0])

        assertValidSize(rows, cols)
        assertAllRowsSameSize(data, cols)

        return createWithData(rows, cols, sliceJoin(data))
}</span>

// NewFromVector creates a matrix from long vector. It just makes sure it can have a
// rectangular shape
func NewFromVec(rows, cols int, data []float64) Matrix <span class="cov8" title="1">{
        assertValidSize(rows, cols)
        if rows*cols != len(data) </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("tried to create %dx%d matrix with %v", rows, cols, data))</span>
        }

        <span class="cov8" title="1">return createWithData(rows, cols, data)</span>
}

// createWithData is called from all constructors and returns a struct
func createWithData(rows, cols int, data []float64) Matrix <span class="cov8" title="1">{
        return Matrix{
                NumRows: rows,
                NumCols: cols,
                data:    data,
        }
}</span>

func assertValidSize(rows, cols int) <span class="cov8" title="1">{
        if rows &lt; 1 || cols &lt; 1 </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("tried to create matrix with %d rows and %d columns", rows, cols))</span>
        }
}

func assertAllRowsSameSize(data [][]float64, cols int) <span class="cov8" title="1">{
        for _, r := range data </span><span class="cov8" title="1">{
                if len(r) != cols </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("tried to create matrix from slice of different sized slices: %v", data))</span>
                }
        }
}

func sliceJoin(data [][]float64) []float64 <span class="cov8" title="1">{
        result := make([]float64, 0, len(data)*len(data[0]))

        for _, r := range data </span><span class="cov8" title="1">{
                result = append(result, r...)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package matrix

import (
        "errors"
        "fmt"
)

// Row returns a slice of the row on the nth index of the matrix.
func (m *Matrix) Row(row int) ([]float64, error) <span class="cov8" title="1">{
        if row &lt; 0 || row &gt;= m.NumRows </span><span class="cov8" title="1">{
                return nil, errors.New(fmt.Sprintf("tried to index %d row from %dx%d matrix", row, m.NumRows, m.NumCols))
        }</span>
        <span class="cov8" title="1">return m.data[row*m.NumCols : (row+1)*m.NumCols], nil</span>
}

// Col returns a slice of the column on the nth index of the matrix.
func (m *Matrix) Col(col int) ([]float64, error) <span class="cov8" title="1">{
        if col &lt; 0 || col &gt;= m.NumCols </span><span class="cov8" title="1">{
                return nil, errors.New(fmt.Sprintf("tried to index %d row col %dx%d matrix", col, m.NumRows, m.NumCols))
        }</span>

        <span class="cov8" title="1">result := make([]float64, 0, m.NumRows)

        for i := 0; i &lt; m.NumRows; i++ </span><span class="cov8" title="1">{
                result = append(result, m.data[i*m.NumCols+col])
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (m *Matrix) Get(row, col int) (float64, error) <span class="cov8" title="1">{
        if row &lt; 0 || col &lt; 0 || row &gt;= m.NumRows || col &gt;= m.NumCols </span><span class="cov8" title="1">{
                return 0, errors.New(fmt.Sprintf("tried to set at wrong index %d:%d in %dx%d matrix", row, col, m.NumRows, m.NumCols))
        }</span>

        <span class="cov8" title="1">return m.data[row*m.NumCols+col], nil</span>
}

func (m *Matrix) Set(row, col int, val float64) error <span class="cov8" title="1">{
        if row &lt; 0 || col &lt; 0 || row &gt;= m.NumRows || col &gt;= m.NumCols </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("tried to set at wrong index %d:%d in %dx%d matrix", row, col, m.NumRows, m.NumCols))
        }</span>

        <span class="cov8" title="1">m.data[row*m.NumCols+col] = val

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package matrix

import "sync"

func Add(lhs, rhs Matrix) (Matrix, error) <span class="cov8" title="1">{
        if err := assertMatchingSizes(lhs.NumRows, lhs.NumCols, rhs.NumRows, lhs.NumCols); err != nil </span><span class="cov8" title="1">{
                return Matrix{}, err
        }</span>

        <span class="cov8" title="1">data := make([]float64, rhs.NumRows*rhs.NumCols)

        for i := range lhs.data </span><span class="cov8" title="1">{
                data[i] = lhs.data[i] + rhs.data[i]
        }</span>

        <span class="cov8" title="1">return NewFromVec(rhs.NumRows, rhs.NumCols, data), nil</span>
}

func Sub(lhs, rhs Matrix) (Matrix, error) <span class="cov8" title="1">{
        if err := assertMatchingSizes(lhs.NumRows, lhs.NumCols, rhs.NumRows, lhs.NumCols); err != nil </span><span class="cov8" title="1">{
                return Matrix{}, err
        }</span>

        <span class="cov8" title="1">data := make([]float64, rhs.NumRows*rhs.NumCols)

        for i := range lhs.data </span><span class="cov8" title="1">{
                data[i] = lhs.data[i] - rhs.data[i]
        }</span>

        <span class="cov8" title="1">return NewFromVec(rhs.NumRows, rhs.NumCols, data), nil</span>
}

func Mult(lhs, rhs Matrix) (Matrix, error) <span class="cov8" title="1">{
        if err := assertMatchingMult(lhs.NumCols, rhs.NumRows); err != nil </span><span class="cov8" title="1">{
                return Matrix{}, err
        }</span>
        <span class="cov8" title="1">result := New(rhs.NumCols, lhs.NumRows)
        wg := sync.WaitGroup{}

        for row := 0; row &lt; lhs.NumRows; row++ </span><span class="cov8" title="1">{
                for col := 0; col &lt; rhs.NumCols; col++ </span><span class="cov8" title="1">{
                        wg.Add(1)

                        lhsRow, _ := lhs.Row(row)
                        rhsCol, _ := rhs.Col(col)

                        go func(i, j int) </span><span class="cov8" title="1">{
                                result.Set(i, j, dot(lhsRow, rhsCol))
                                wg.Done()
                        }</span>(row, col)
                }
        }
        <span class="cov8" title="1">wg.Wait()

        return result, nil</span>
}

// Trans returns a new matrix which represents the transposed version of the first.
func Trans(m Matrix) (Matrix, error) <span class="cov0" title="0">{
        data := make([]float64, 0, m.NumRows*m.NumCols)

        for i := 0; i &lt; m.NumCols; i++ </span><span class="cov0" title="0">{

                col, err := m.Col(i)
                if err != nil </span><span class="cov0" title="0">{
                        return Matrix{}, err
                }</span>

                <span class="cov0" title="0">data = append(data, col...)</span>
        }

        <span class="cov0" title="0">return NewFromVec(m.NumCols, m.NumRows, data), nil</span>
}

// Equal compares to matrices for equality.
func Equal(rhs, lhs Matrix) bool <span class="cov8" title="1">{
        if rhs.NumRows != lhs.NumRows || rhs.NumCols != lhs.NumCols </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range rhs.data </span><span class="cov8" title="1">{
                if rhs.data[i] != lhs.data[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package matrix

import (
        "errors"
        "fmt"
)

func assertMatchingSizes(lhsRow, lhsCol, rhsRow, rhsCol int) error <span class="cov8" title="1">{
        if lhsRow != rhsRow || lhsCol != rhsCol </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("can't add non matching matrices: mat: %dx%d, other: %dx%d", lhsRow, lhsCol, rhsRow, rhsCol))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func assertMatchingMult(lhsCol, rhsRow int) error <span class="cov8" title="1">{
        if lhsCol != rhsRow </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("can't multiply non matching matrices: mat: %d columns and other: %d rows", lhsCol, rhsRow))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func dot(row, col []float64) (r float64) <span class="cov8" title="1">{
        for i := range row </span><span class="cov8" title="1">{
                r += row[i] * col[i]
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package matrix

import (
        "errors"
        "sync"
)

// AddScalar adds a value to all elements in matrix.
func (m *Matrix) AddScalar(val float64) <span class="cov8" title="1">{
        for i := range m.data </span><span class="cov8" title="1">{
                m.data[i] += val
        }</span>
}

// Add adds a value to first matrix and saves result in its data.
// Both matrices should have the same dimensions.
func (m *Matrix) Add(other Matrix) error <span class="cov8" title="1">{
        if err := assertMatchingSizes(m.NumRows, m.NumCols, other.NumRows, other.NumCols); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range m.data </span><span class="cov8" title="1">{
                m.data[i] += other.data[i]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Add subtracts a value to first matrix and saves result in its data.
// Both matrices should have the same dimensions.
func (m *Matrix) Sub(other Matrix) error <span class="cov8" title="1">{
        if err := assertMatchingSizes(m.NumRows, m.NumCols, other.NumRows, other.NumCols); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range m.data </span><span class="cov8" title="1">{
                m.data[i] -= other.data[i]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MultScalar multiplies all elements of matrix by value.
func (m *Matrix) MultScalar(val float64) <span class="cov8" title="1">{
        for i := range m.data </span><span class="cov8" title="1">{
                m.data[i] *= val
        }</span>
}

// Mult multiplies two matrices and saves result in first one.
// The two matrices must look the same, otherwise the shape of the first needs
// to change.
func (m *Matrix) Mult(other Matrix) error <span class="cov8" title="1">{
        if err := assertMatchingSizes(m.NumRows, m.NumCols, other.NumRows, other.NumCols); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !m.IsSquare() </span><span class="cov8" title="1">{
                return errors.New("the multiply method should only work on square matrices")
        }</span>

        <span class="cov8" title="1">wg := sync.WaitGroup{}
        tmp := New(m.NumRows, m.NumCols)

        for row := 0; row &lt; m.NumRows; row++ </span><span class="cov8" title="1">{
                for col := 0; col &lt; other.NumCols; col++ </span><span class="cov8" title="1">{
                        wg.Add(1)

                        lhsRow, _ := m.Row(row)
                        rhsCol, _ := other.Col(col)

                        go func(i, j int) </span><span class="cov8" title="1">{
                                tmp.Set(i, j, dot(lhsRow, rhsCol))
                                wg.Done()
                        }</span>(row, col)
                }
        }
        <span class="cov8" title="1">wg.Wait()
        m.data = tmp.data

        return nil</span>
}

// Trans transposes the matrix in place.
func (m *Matrix) Trans() error <span class="cov0" title="0">{
        tmp := make([]float64, 0, m.NumRows*m.NumCols)

        for i := 0; i &lt; m.NumCols; i++ </span><span class="cov0" title="0">{

                col, err := m.Col(i)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">tmp = append(tmp, col...)</span>
        }
        <span class="cov0" title="0">m.data = tmp
        m.NumRows, m.NumCols = m.NumCols, m.NumRows

        return nil</span>
}

// Equal compares the instance matrix with another.
func (m *Matrix) Equal(other Matrix) bool <span class="cov8" title="1">{
        if m.NumRows != other.NumRows || m.NumCols != other.NumCols </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range m.data </span><span class="cov8" title="1">{
                if m.data[i] != other.data[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (m *Matrix) IsSquare() bool <span class="cov8" title="1">{
        return m.NumRows == m.NumCols
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package matrix

import (
        "fmt"
)

func (m Matrix) String() (s string) <span class="cov0" title="0">{
        for i := 0; i &lt; m.NumRows; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; m.NumCols; j++ </span><span class="cov0" title="0">{
                        elem, _ := m.Get(i, j)
                        s += fmt.Sprintf("%.2f", elem)
                        s += " "
                }</span>
                <span class="cov0" title="0">s += "\n"</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
